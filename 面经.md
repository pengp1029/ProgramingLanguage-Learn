# Go面经
1. 内存逃逸
目的：在内存安全和性能高效中找到平衡。避免栈内存导致的悬垂引用（访问无效内存）
本质：本来应该在栈上分配的变量，因为某些原因，被分配到了堆上。是编译器优化的一种手段。
经常出现的场景：
- 闭包、被协程引用
```go
func main(){
    for i := 0; i < 10; i++ {
        defer func() {
            fmt.Println(i)
        }()
    }
}
```
- 指针逃逸，函数返回局部变量的地址
```go
func NewHelloWorldStr() byte* {
    b := []byte("hello world")
    return &b
}
```
- 变量大小不确定/变量大小超出栈容量限制
- 动态类型创建：map、chan、interface{}





